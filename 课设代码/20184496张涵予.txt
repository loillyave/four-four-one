
#include <iostream>
#include <vector>
#include <stack>
#include <string>
#include<stdlib.h>
#include <cstring>
#include <string.h>

using namespace std;

typedef struct VN
{
	string symbol;
	vector<string> p;//该非终结符的产生式
	vector<string> first;//该非终结符的FIRST集
	vector<string> follow;//该非终结符的FOLLOW集
}N;//非终结符
typedef  struct VT
{
	string vt;
}T;//终结符, num 用 n 代替
vector<N> vn;//定义非终结符集合
vector<T> vt;//定义终结符集合
vector< vector<string> > tab;//分析表

void getN(vector<N> *n)//获取非终结符
{
    string c[]={"A","B","C","D","E","F","G","H","I","J","K","M","N","O","P","Q","R","S","T","U","V","W","X"};
    for(int i=0;i<23;i++)
    {
       N temp;
       temp.symbol=c[i];
       n->push_back(temp);
    }


}
void getT(vector<T> *t)//获取终结符
{
    string c[]={"int","float","char","void","+","-","*","/","(",")","{","}","'","<",">","=","<=",">=","id","num","ch","if","else","while","return","cout","cin",";",","};
    for(int i=0;i<29;i++)
    {
        T temp;
        temp.vt=c[i];
        t->push_back(temp);
    }
}
void getpRules(vector<N> *n)//获取产生式
{
    string rule[]={"A%F&id&(&G&)&{&H&}&#",
                   "F%int&#",
                   "F%float&#",
                   "F%char&#",
                   "F%void&#",
                   "F%$&#",
                   "G%I&E|$&#",
                   "E%,&I&E&#",
                   "E%$&#",
                   "I%F&id&J&#",
                   "I%id&J&#",
                   "J%=&K&#",
                   "J%$&#",
                   "H%M&N&#",
                   "M%I&;&M&#",
                   "M%N&#",
                   "M%$&#",
                   "N%O&N&#",
                   "N%P&N&#",
                   "N%Q&N&#",
                   "N%R&N&#",
                   "N%S&N&#",
                   "N%T&N&#",
                   "N%$&#",
                   "O%id&=&K&;&#",
                   "P%while&(&U&)&{&H&}&#",
                   "U%K&V&K&#",
                   "V%<&#",
                   "V%>&#",
                   "V%=&#",
                   "V%<=&#",
                   "V%>=&#",
                   "Q%if&(&U&)&{&H&}&W&#",
                   "W%else&{&H&}&#",
                   "W%$&#",
                   "R%return&K&;&#",
                   "S%cout&<&<&id&;&#",
                   "S%cout&<&<&num&;&#",
                   "S%cout&<&<&’&ch&’&;&#",
                   "T%cin&>&>&id&;&#",
                   "K%C&D&#",
                   "B%(&K&)&#",
                   "B%id&#",
                   "B%num&#",
                   "B%’&ch&’&#",
                   "C%B&X&#",
                   "X%*&B&X&#",
                   "X%/&B&X&#",
                   "X%$&#",
                   "D%+&C&D&#",
                   "D%-&C&D&#",
                   "D%$&#"};
    for(int i=0;i<52;i++)
    {
        for(int j=0;j<(n->size());j++)
        {
            string s(rule[i],0,1);
            if(s==n->at(j).symbol)
            {
                n->at(j).p.push_back(rule[i]);
            }
        }
    }
}
bool isVN(string s , vector<N> n)//判断字符是否为非终结符
{
	int judge = 0 , count = 0;
	if (n.size() > 0)
	{
		for (int i = 0; i < n.size(); i++)
		{
			count = i;
			if (s == n.at(i).symbol)
			{
				judge = 1;
				return true;
			}
		}
		if ((count == (n.size() - 1)) && (judge == 0))
		{
			return false;
		}
	}
	else
		return false;
}
bool isVT(string s , vector<T> t)//判断符号(除了num)是否为终结符,
{
	int judge = 0, count = 0;
	if (t.size() > 0 )
	{
		for (size_t i = 0; i < t.size(); i++)
		{
			count = i;
			if (s==t.at(i).vt)
			{
				judge = 1;
				return true;
			}
		}
		if (count == (t.size() - 1) && (judge == 0))
		{
			return false;
		}
	}
	else
		return false;
}
bool isEmptyIn(N n)//判断非终结符FIRST集是否含有空元素，有空元素(true);没空元素(false)
{
	int jugde = 0, i = 0;
	for (i = 0; i < n.first.size(); i++)
	{
		if (n.first.at(i) == "$")
		{
			jugde = 1;
			return true;
		}
	}
	if ((i == (n.first.size()) - 1) && (jugde == 0))
	{
		return false;
	}
}
int getVnPos(string s, vector<N> n)
/*获取某个非终结符在非终结符集合中的位置,
 若当前符号不在非终结符集合返回-1*/
{
	if (isVN(s, n) == true)//判断当前符号是否在非终结符集合
	{
		for (size_t i = 0; i < n.size(); i++)
		{
			if (s == n.at(i).symbol)
			{
				return i;
			}
		}
	}
	else
		return -1;
}

int getVtPos(string c, vector<T> t)
//获取某个终结符在终结符集合中的位置
{
	if (isVT(c , t) == true)//判断当前符号是否在终结符集合
	{
		for (int i = 0; i < t.size(); i++)
		{
			if (c == t.at(i).vt)
			{
				return i;
			}
		}
	}
	else
		return -1;
}
bool isExist(string c, N n, int i)
/*判断新求得的元素 是否和之前FIRST(1)/FOLLOW(2)集重复
	若重复返回true，不重复返回false
*/
{
	switch (i)
	{
	case 1://验证FIRST集
		if (n.first.size() == 0)
		{
			return false;
		}
		else
		{
			int judge = 0, count = 0;
			for (int i = 0; i < n.first.size(); i++)
			{
				count = i;
				if (n.first.at(i) == c)
				{
					judge = 1;
					return true;
				}
			}
			if ((judge == 0) && (count == (n.first.size() - 1)))
			{
				return false;
			}
		}
		break;
	case 2://验证FOLLOW集
		if (n.follow.size() == 0)
		{
			return false;
		}
		else
		{
			int judge = 0, count = 0;
			for (int i = 0; i < n.follow.size(); i++)
			{
				count = i;
				if (n.follow.at(i) == c)
				{
					judge = 1;
					return true;
				}
			}
			if ((judge == 0) && (count == (n.follow.size() - 1)))
			{
				return false;
			}
		}
		break;
	}
}
string getrulefirst(string t)//求产生式推出第一个字符
{
    int i=2;
    int j=0;
    while(1)
    {
        j++;
        if(t.at(j)=='&')
            break;
    }
    string s(t,2,j-2);
    return s;
}

void getFirst(vector<N> *n)//求每个非终结符的FIRST集
{
	int new_ = 0;//为1时重复求FIRST集，为0时结束循环
	unsigned int loc_vn = 0, loc_p = 0;//for循环中的计数器
	int count = 0;
	do//求FIRST集
	{
		for (loc_vn= 0; loc_vn < n->size(); loc_vn++)
			//对于位置在loc_vn的非终结符，根据其产生式求FIRST集
		{
			vector<string> temp = n->at(loc_vn).p;//该非终结符的产生式集合
			if ((temp.size()) > 0)
				//产生式的数目大于0
			{
				//分析每个产生式的情况
				for (loc_p = 0; loc_p < (temp.size()); loc_p++)
					//分析第i个产生式
				{
					string c_loc3 =getrulefirst(temp.at(loc_p)) ;//中间变量，每个产生式位置3处的字符

					if (isVN(c_loc3, vn) == true)
						//该非终结符的第i个产生式推出的第一个符号，例如E->E+F中的E  是非终结符
					{
						int n_loc3 = getVnPos(c_loc3, vn);
						if (n->at(n_loc3).first.size() == 0)
						{
							count++;
						}
						else
						{
							vector<string> n3_first = n->at(n_loc3).first;//中间变量，产生式中非终结符的FIRST集
							for (int i = 0; i < n3_first.size(); i++)
							{
								if (isExist(n3_first.at(i), n->at(loc_vn), 1) == false)
								{
									n->at(loc_vn).first.push_back(n3_first.at(i));
								}
							}
						}
					}
					if (isVT(c_loc3, vt) == true || (c_loc3 == "$"))
						//该非终结符的第i个产生式推出的第一个符 号，例如E->*F中的*     是终结符
					{
						if (isExist(c_loc3, n->at(loc_vn) , 1) == false)
						{
							n->at(loc_vn).first.push_back(c_loc3);
						}
					}
				}
			}
		}
		//确定是否循环求FIRST集
		if (count > 0)
		{
			new_ = 1;
		}
		else
		{
			new_ = 0;
		}
		count = 0;
	} while (new_ == 1);//循环求每个非终结符的FIRST集，直到每个集合不再添加新的元素结束循环
}
void getFollow(vector<N> *n)//获取非终结符的FOLLOW集
{
	int count = 20;
	unsigned int loc_vn = 0, loc_p = 0, loc_c = 0;//for循环中的计数器
	do
	{
		//按非终结符的顺序 遍历所有的产生式
		for (loc_vn = 0; loc_vn < n->size(); loc_vn++)
			//对于位置在loc_vn的非终结符，根据其产生式求FIRST集
		{
			if (isExist("#", n->at(0) , 2) == false)
			{
				n->at(0).follow.push_back("#");//起始符的FOLLOW集加入'#'符号
			}
			vector<string> temp = n->at(loc_vn).p;//该非终结符的产生式 集合
			if ((temp.size()) > 0)
			//产生式的数目大于0
			{
				//分析每个产生式的情况
				for (loc_p = 0; loc_p < (temp.size()); loc_p++)
				//分析第loc_p个产生式
				{
					for (loc_c = 3; loc_c < temp.at(loc_p).size(); loc_c++)
					//分析该产生式的第loc_c个字符,从loc_c = 3的位置开始,对出现的所有非终结符求FOLLOW集
					{
						char tempc = temp.at(loc_p).at(loc_c);//临时变量，保存当前要分析的 字符
						if ((isVN(tempc , vn) == true))//该字符为 非终结符，求该字符的FOLLOW集
					    //该字符为 非终结符 且后续至少有一个字符，读取下一个字符，判断是否为空
						{
							int pos_tempc = getVnPos(tempc, vn);//求该字符的FOLLOW集
							unsigned int loc_tempc;//FOLLOW集中的字符
							for (loc_tempc = loc_c; loc_tempc < temp.at(loc_p).size(); loc_tempc++)
							{
								if (loc_tempc == (temp.at(loc_p).size() - 1))//产生式的最后一个符号是非终结符
								{
									int pos1 = getVnPos(temp.at(loc_p).at(0), vn);//
									if ((n->at(pos1).follow.size() == 0))
									{
										count++;
									}
									else
									{
										vector<char> pos1_follow = n->at(pos1).follow;//产生式中非终结符(第一个字符)的FOLLOW集
										for (size_t i = 0; i < pos1_follow.size(); i++)
										{
											if (isExist(pos1_follow.at(i), n->at(pos_tempc), 2) == false)
												//FOLLOW集没有该元素
											{
												n->at(pos_tempc).follow.push_back(pos1_follow.at(i));
											}
										}
									}
								}
								else
								//当前分析的字符不是产生式的倒数第一个字符
								{
									char c = temp.at(loc_p).at(loc_tempc + 1);
									if (c == '#')
										//非终结符后的第一个字符为空
										continue;
									else
										//非终结符后的第一个字符不为空
									{
										if (isVT(c , vt) == true)
											//是非空的终结符
										{
											if (isExist(c, n->at(pos_tempc), 2) == false)
											{
												n->at(pos_tempc).follow.push_back(c);
											}
											break;
										}
										if (isVN(c , vn) == true)
											//是非终结符
										{
											//遍历该非终结符的FIRST集
											int i = getVnPos(c, vn);
											for (size_t j = 0; j < n->at(i).first.size(); j++)
											{
												if (n->at(i).first.at(j) == '#')
													//FIRST集含中的空的元素
												{
													;
												}
												else
													//非空元素
												{
													if (isExist(n->at(i).first.at(j), n->at(pos_tempc), 2) == false)
													{
														n->at(pos_tempc).follow.push_back(n->at(i).first.at(j));
													}
							 					}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		count --;
	} while (count > 0);
}
